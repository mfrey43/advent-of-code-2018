import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.time.StopWatch;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Day6 {

  public static void main(String[] args) throws IOException {
//    System.out.println(new Day6().part1());

    StopWatch stopwatch = new StopWatch();
    stopwatch.start();
    System.out.println(new Day6().part2());
    stopwatch.stop();
    System.out.println(stopwatch.getTime());

    List<Point> testPoints = new ArrayList<>();
    testPoints.add(new Point(0, 1, 1));
    testPoints.add(new Point(1, 1, 6));
    testPoints.add(new Point(2, 8, 3));
    testPoints.add(new Point(3, 3, 4));
    testPoints.add(new Point(4, 5, 5));
    testPoints.add(new Point(5, 8, 9));
//    new Day6().calcLargestArea(testPoints);
//    System.out.println(new Day6().calcLargestAreaWithinDistance(testPoints, 32));
  }

  public String part1() throws IOException {
    String input = IOUtils.toString(getClass().getResourceAsStream("input_day_06.txt"), StandardCharsets.UTF_8);

    List<Point> points = new ArrayList<>();
    int pointNumber = 0;
    for (String line : input.split("\n")) {
      String[] split = line.split(", ");
      int x = Integer.parseInt(split[0]);
      int y = Integer.parseInt(split[1]);
      points.add(new Point(pointNumber, x, y));
      pointNumber++;
    }

    return calcLargestArea(points);
  }

  public String part2() throws IOException {
    String input = IOUtils.toString(getClass().getResourceAsStream("input_day_06.txt"), StandardCharsets.UTF_8);

    List<Point> points = new ArrayList<>();
    int pointNumber = 0;
    for (String line : input.split("\n")) {
      String[] split = line.split(", ");
      int x = Integer.parseInt(split[0]);
      int y = Integer.parseInt(split[1]);
      points.add(new Point(pointNumber, x, y));
      pointNumber++;
    }

    return calcLargestAreaWithinDistance(points, 9999);
  }

  private String calcLargestAreaWithinDistance(List<Point> points, int maxDistance) {
    int middleX = points.stream().mapToInt(Point::getX).sum() / points.size();
    int middleY = points.stream().mapToInt(Point::getY).sum() / points.size();

    int numPoints = 0;
    for(int y = -maxDistance; y <= maxDistance; y++){
      for(int x = -maxDistance + Math.abs(y); x <= maxDistance - Math.abs(y); x++){
        int finalX = middleX + x;
        int finalY = middleY + y;
        if(points.stream().mapToInt(p -> p.getDistance(finalX, finalY)).sum() < maxDistance){
//          System.out.println("(" + finalX + "," + finalY + ")");
          numPoints++;
        }
      }
    }
    return String.valueOf(numPoints);
  }

  private String calcLargestArea(List<Point> points) {
    List<Point> collect = points.stream().filter(point -> point.hasFiniteArea(points)).collect(Collectors.toList());

    Map<Point, Integer> map = new HashMap<>();

    for (Point point : collect) {
      int numberOfPoints = 1;
      boolean pointsInLastRun;
      int currentRadius = 1;
      do {
        pointsInLastRun = false;
        for (int i = 0; i < currentRadius * 2; i++) {
          final int x1 = -currentRadius + i;
          final int y1 = -currentRadius;
          if (point.equals(closestPoint(point.getX() + x1, point.getY() + y1, points))) {
            numberOfPoints++;
            pointsInLastRun = true;
          }

          final int x2 = currentRadius;
          final int y2 = -currentRadius + i;
          if (point.equals(closestPoint(point.getX() + x2, point.getY() + y2, points))) {
            numberOfPoints++;
            pointsInLastRun = true;
          }

          final int x3 = currentRadius - i;
          final int y3 = currentRadius;
          if (point.equals(closestPoint(point.getX() + x3, point.getY() + y3, points))) {
            numberOfPoints++;
            pointsInLastRun = true;
          }

          final int x4 = -currentRadius;
          final int y4 = currentRadius - i;
          if (point.equals(closestPoint(point.getX() + x4, point.getY() + y4, points))) {
            numberOfPoints++;
            pointsInLastRun = true;
          }
        }
        currentRadius++;
      } while (pointsInLastRun && numberOfPoints < 10000);

      map.put(point, numberOfPoints);
    }


    /*
    int[][] grid = new int[yMax + 1][xMax + 1];

    for (int y = 0; y < grid.length; y++) {
      for (int x = 0; x < grid[y].length; x++) {
        int thisX = x;
        int thisY = y;
        List<Integer> distances = points.stream().map(p -> p.getDistance(thisX, thisY)).collect(Collectors.toList());
        Optional<Integer> min = distances.stream().min(Comparator.comparingInt(Integer::intValue));
        if (min.isPresent()) {
          if (distances.stream().filter(d -> d.equals(min.get())).count() == 1) {
            grid[thisY][thisX] = distances.indexOf(min.get());
          } else {
            grid[thisY][thisX] = -1;
          }
        }
      }
    }
    */

    map.forEach((k, v) -> {
      System.out.println(k.getId() + ": " + v + " (" + k.getX() + "," + k.getY() + ")");
    });

    return "TODO";
  }

  private Point closestPoint(int x, int y, List<Point> points) {
    Point min = null;
    double minDistance = Double.MAX_VALUE;
    List<Double> distances = new ArrayList<>();
    for (Point point : points) {
      double distance = point.getDistance(x, y);
      distances.add(distance);
      if (distance < minDistance) {
        minDistance = distance;
        min = point;
      }
    }
    double finalMinDistance = minDistance;
    if(distances.stream().filter(aDouble -> aDouble == finalMinDistance).count() > 1){
      return null;
    }
    return min;
  }

  private static class Point {

    private int id;
    private int x;
    private int y;

    public Point(int id, int x, int y) {
      this.id = id;
      this.x = x;
      this.y = y;
    }

    public int getDistance(int otherX, int otherY) {
      return Math.abs(x - otherX) + Math.abs(y - otherY);
    }

    public boolean hasFiniteArea(List<Point> points) {
      boolean topLeft = false;
      boolean topRight = false;
      boolean bottomLeft = false;
      boolean bottomRight = false;
      for (Point point : points) {
        if (point == this) {
          continue;
        }
        if (point.getX() <= x) {
          if (point.getY() >= y) {
            bottomLeft = true;
          }
          if (point.getY() <= y) {
            topLeft = true;
          }
        } else if (point.getX() >= x) {
          if (point.getY() >= y) {
            bottomRight = true;
          }
          if (point.getY() <= y) {
            topRight = true;
          }
        }
      }
      return topLeft && topRight && bottomLeft && bottomRight;
    }

    public int getId() {
      return id;
    }

    public void setId(int id) {
      this.id = id;
    }

    public int getX() {
      return x;
    }

    public void setX(int x) {
      this.x = x;
    }

    public int getY() {
      return y;
    }

    public void setY(int y) {
      this.y = y;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o)
        return true;
      if (o == null || getClass() != o.getClass())
        return false;
      Point point = (Point) o;
      return id == point.id;
    }

    @Override
    public int hashCode() {
      return Objects.hash(id);
    }
  }
}
